{
  "name": "Sprint Summary",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "=0 6 * * 1-5"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -160,
        -40
      ],
      "id": "1d2f73a3-a546-4484-ab46-57ca2499b491",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "sendTo": "george.farias@f4g.com.br",
        "subject": "={{ $json.subject }}",
        "message": "={{ $json.emailHtml }}",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        1420,
        -20
      ],
      "id": "17ad1ac1-d579-461b-8aaf-780c5fa2bb7d",
      "name": "Gmail",
      "webhookId": "ed526138-a877-42bd-a4fe-3a271b7de2c8",
      "credentials": {
        "gmailOAuth2": {
          "id": "9eY5yubWIBMcDRl1",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Função auxiliar para verificar se um valor existe\nfunction exists(value) {\n\treturn value !== null && value !== undefined;\n}\n\n// Função auxiliar para calcular a data de término de uma sprint\nfunction calculateEndDate(startDate, durationDays) {\n\tif (!startDate || !durationDays) return null;\n\n\tconst date = new Date(startDate);\n\tdate.setDate(date.getDate() + parseInt(durationDays) - 1); // Subtrair 1 porque a data de início já conta como dia 1\n\treturn date.toISOString().split('T')[0]; // Retorna apenas a parte da data (YYYY-MM-DD)\n}\n\n// Função para calcular a idade da issue em dias\nfunction calculateIssueDuration(createdAt, updatedAt) {\n\tif (!createdAt || !updatedAt) return 0;\n\n\tconst created = new Date(createdAt);\n\tconst updated = new Date(updatedAt);\n\tconst durationMs = updated - created;\n\n\t// Converte para dias\n\treturn Math.floor(durationMs / (1000 * 60 * 60 * 24));\n}\n\nlet projectData,\n\titems = [];\n\n// Verifica se estamos em ambiente local\nif (typeof $input === 'undefined') {\n\tconsole.log('Ambiente local detectado, carregando data.json');\n\tconst fs = require('fs');\n\tlet localData = JSON.parse(fs.readFileSync('./data.json', 'utf8'));\n\n\t$input = {\n\t\titem: { json: localData },\n\t};\n\tconsole.log('Arquivo data.json carregado com sucesso');\n}\n\ntry {\n\tprojectData = $input.item.json.data.organization.projectV2;\n\titems = projectData.items.nodes;\n} catch (error) {\n\treturn {\n\t\tjson: {\n\t\t\terror: true,\n\t\t\tmessage: `Erro ao processar dados: ${error.message}`,\n\t\t\tinputStructure: JSON.stringify($input).substring(0, 500) + '...',\n\t\t},\n\t};\n}\n\n// Inicializa contadores\nconst statusCounts = {};\nconst priorityCounts = {};\nconst assigneeCounts = {}; // Número de issues por usuário\nconst assigneeBugCounts = {}; // Número de bugs por usuário\nconst assigneeEstimates = {}; // Total de pontos por usuário\nconst assigneeStatusCounts = {}; // Contagem de issues por status por usuário\nconst assigneeDetails = {}; // Detalhes detalhados por usuário\nconst issuesByStatus = {};\nconst bugsByStatus = {}; // Bugs organizados por status\nconst bugsByPriority = {}; // Bugs organizados por prioridade\nconst sprintCounts = {};\nconst issueTypeCounts = {}; // Para contar os tipos de issues (bugs, etc.)\nconst estimateTotals = {}; // Para armazenar o total de pontos por status\nconst bugResolutionTimes = []; // Armazena tempos de resolução de bugs\nlet totalEstimatePoints = 0; // Total de pontos em todas as issues\nlet deliveredPoints = 0; // Total de pontos em issues fechadas\nlet pendingPoints = 0; // Total de pontos em issues ainda não fechadas\nlet bugCount = 0; // Contador específico para bugs\nlet pendingBugCount = 0; // Contador para bugs pendentes\nlet deliveredBugCount = 0; // Contador para bugs fechados\nlet bugPoints = 0; // Total de pontos em bugs\nlet deliveredBugPoints = 0; // Pontos em bugs fechados\nlet pendingBugPoints = 0; // Pontos em bugs pendentes\n\n// Armazena informações sobre sprints\nconst sprintInfo = {};\nlet currentSprint = null;\nlet currentSprintId = null;\n// Primeira passagem: Identifica a sprint atual\n// Precisamos fazer isso primeiro para depois filtrar apenas issues da sprint atual\nitems.forEach((item) => {\n\tif (!exists(item) || !exists(item.fieldValues?.nodes)) return;\n\n\titem.fieldValues.nodes.forEach((fieldValue) => {\n\t\tif (\n\t\t\t!exists(fieldValue) ||\n\t\t\t!exists(fieldValue.field) ||\n\t\t\tfieldValue.field.name !== 'Sprint' ||\n\t\t\t!exists(fieldValue.title)\n\t\t)\n\t\t\treturn;\n\n\t\tconst sprint = fieldValue.title;\n\t\tconst sprintId = fieldValue.iterationId;\n\t\tconst sprintStartDate = fieldValue.startDate;\n\t\tconst sprintDuration = fieldValue.duration;\n\n\t\t// Armazena informações da sprint\n\t\tif (!sprintInfo[sprintId]) {\n\t\t\tsprintInfo[sprintId] = {\n\t\t\t\ttitle: sprint,\n\t\t\t\tstartDate: sprintStartDate,\n\t\t\t\tduration: sprintDuration,\n\t\t\t\tendDate: calculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t};\n\t\t}\n\n\t\t// Determina a sprint atual com base na data\n\t\tconst today = new Date();\n\t\tconst sprintStart = new Date(sprintStartDate);\n\t\tconst sprintEnd = new Date(\n\t\t\tcalculateEndDate(sprintStartDate, sprintDuration),\n\t\t);\n\n\t\tif (today >= sprintStart && today <= sprintEnd) {\n\t\t\tcurrentSprint = sprintInfo[sprintId];\n\t\t\tcurrentSprintId = sprintId;\n\t\t}\n\t});\n});\n\n// Se não encontrou nenhuma sprint atual, usa a data atual para avisar\nif (!currentSprint) {\n\tconsole.log('Nenhuma sprint ativa no momento. Processando todos os itens.');\n} else {\n\tconsole.log(\n\t\t`Sprint atual identificada: ${currentSprint.title} (${currentSprint.startDate} a ${currentSprint.endDate})`,\n\t);\n}\n\n// Filtra apenas itens da sprint atual (se uma for encontrada)\nconst currentSprintItems = currentSprintId\n\t? items.filter((item) => {\n\t\t\tif (!exists(item) || !exists(item.fieldValues?.nodes)) return false;\n\n\t\t\t// Verifica se o item pertence à sprint atual\n\t\t\treturn item.fieldValues.nodes.some(\n\t\t\t\t(fieldValue) =>\n\t\t\t\t\texists(fieldValue) &&\n\t\t\t\t\texists(fieldValue.field) &&\n\t\t\t\t\tfieldValue.field.name === 'Sprint' &&\n\t\t\t\t\texists(fieldValue.iterationId) &&\n\t\t\t\t\tfieldValue.iterationId === currentSprintId,\n\t\t\t);\n\t  })\n\t: items; // Se não houver sprint atual, usa todos os itens\n\n// Log de informações de filtragem\nif (currentSprintId) {\n\tif (currentSprintItems.length === 0) {\n\t\tconsole.log(\n\t\t\t`Alerta: Não foram encontradas issues na sprint atual (${currentSprint.title})`,\n\t\t);\n\t} else {\n\t\tconsole.log(\n\t\t\t`Filtrando apenas itens da sprint atual: ${\n\t\t\t\tcurrentSprintItems.length\n\t\t\t} de ${items.length} itens (${Math.round(\n\t\t\t\t(currentSprintItems.length / items.length) * 100,\n\t\t\t)}%)`,\n\t\t);\n\t}\n} else {\n\tconsole.log(\n\t\t`Processando todos os ${items.length} itens, sem filtro de sprint.`,\n\t);\n}\n\n// Processa cada item da sprint atual\ncurrentSprintItems.forEach((item) => {\n\t// Pula itens sem conteúdo\n\tif (!exists(item) || !exists(item.content)) return;\n\n\tconst issue = item.content;\n\n\t// Verifica se há um tipo de issue diretamente no objeto content\n\tif (exists(issue.issueType) && exists(issue.issueType.name)) {\n\t\tconst contentIssueType = issue.issueType.name;\n\n\t\t// Atualiza o contador de bugs\n\t\tif (contentIssueType.toLowerCase().includes('bug')) {\n\t\t\tbugCount++;\n\t\t}\n\t\t\n\t\t// O tipo de issue será contabilizado mais tarde\n\t}\n\n\t// Valores padrão\n\tlet status = 'No Status';\n\tlet priority = 'No Priority';\n\tlet sprint = 'No Sprint';\n\tlet issueType = 'No Type'; // Valor padrão para tipo de issue\n\tlet sprintId = null;\n\tlet sprintStartDate = null;\n\tlet sprintDuration = null;\n\tlet estimate = 0; // Valor padrão para estimativa/pontos\n\n\t// Tenta encontrar status e prioridade\n\tif (exists(item.fieldValues?.nodes)) {\n\t\titem.fieldValues.nodes.forEach((fieldValue) => {\n\t\t\tif (!exists(fieldValue) || !exists(fieldValue.field)) return;\n\n\t\t\tif (fieldValue.field.name === 'Status' && exists(fieldValue.name)) {\n\t\t\t\tstatus = fieldValue.name;\n\t\t\t}\n\t\t\tif (fieldValue.field.name === 'Priority' && exists(fieldValue.name)) {\n\t\t\t\tpriority = fieldValue.name;\n\t\t\t}\n\t\t\t// Captura o tipo de issue (Bug, etc.) - verificando nos campos personalizados\n\t\t\tif (fieldValue.field.name === 'Type' && exists(fieldValue.name)) {\n\t\t\t\tissueType = fieldValue.name;\n\n\t\t\t\t// Incrementa o contador de bugs se o tipo for Bug\n\t\t\t\tif (issueType.toLowerCase().includes('bug')) {\n\t\t\t\t\tbugCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Captura o valor de estimativa/pontos\n\t\t\tif (fieldValue.field.name === 'Estimate' && exists(fieldValue.number)) {\n\t\t\t\testimate = parseFloat(fieldValue.number) || 0;\n\t\t\t}\n\t\t\t// Captura informações da sprint\n\t\t\tif (fieldValue.field.name === 'Sprint' && exists(fieldValue.title)) {\n\t\t\t\tsprint = fieldValue.title;\n\t\t\t\tsprintId = fieldValue.iterationId;\n\t\t\t\tsprintStartDate = fieldValue.startDate;\n\t\t\t\tsprintDuration = fieldValue.duration;\n\n\t\t\t\t// Armazena informações da sprint para uso posterior\n\t\t\t\tif (!sprintInfo[sprintId]) {\n\t\t\t\t\tsprintInfo[sprintId] = {\n\t\t\t\t\t\ttitle: sprint,\n\t\t\t\t\t\tstartDate: sprintStartDate,\n\t\t\t\t\t\tduration: sprintDuration,\n\t\t\t\t\t\tendDate: calculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Determina a sprint atual com base na data\n\t\t\t\tconst today = new Date();\n\t\t\t\tconst sprintStart = new Date(sprintStartDate);\n\t\t\t\tconst sprintEnd = new Date(\n\t\t\t\t\tcalculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t\t);\n\n\t\t\t\tif (today >= sprintStart && today <= sprintEnd) {\n\t\t\t\t\tcurrentSprint = sprintInfo[sprintId];\n\t\t\t\t\tcurrentSprintId = sprintId;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// Conta por status\n\tstatusCounts[status] = (statusCounts[status] || 0) + 1;\n\n\t// Acumula pontos de estimativa por status\n\tif (!estimateTotals[status]) {\n\t\testimateTotals[status] = 0;\n\t}\n\testimateTotals[status] += estimate;\n\ttotalEstimatePoints += estimate;\n\n\t// Calcula pontos entregues vs. pontos pendentes\n\t// Determina se a issue é um bug\n\tconst isBug =\n\t\texists(issue.issueType) &&\n\t\tissue.issueType.name.toLowerCase().includes('bug');\n\n\t// Calcula pontos entregues vs. pontos pendentes\n\tif (issue.state === 'CLOSED') {\n\t\tdeliveredPoints += estimate;\n\n\t\t// Se for um bug, incremente o contador de bugs entregues\n\t\tif (isBug) {\n\t\t\tdeliveredBugCount++;\n\t\t\tdeliveredBugPoints += estimate; // Adiciona aos pontos de bugs entregues\n\t\t}\n\t} else {\n\t\tpendingPoints += estimate;\n\n\t\t// Se for um bug, incremente o contador de bugs pendentes\n\t\tif (isBug) {\n\t\t\tpendingBugCount++;\n\t\t\tpendingBugPoints += estimate; // Adiciona aos pontos de bugs pendentes\n\t\t}\n\t}\n\n\t// Rastreia bugs por status\n\tif (isBug) {\n\t\t// Adiciona aos pontos totais de bugs\n\t\tbugPoints += estimate;\n\n\t\t// Adiciona aos pontos de bugs entregues ou pendentes\n\t\tif (issue.state === 'CLOSED') {\n\t\t\tdeliveredBugPoints += estimate;\n\n\t\t\t// Calcula o tempo de resolução para bugs fechados\n\t\t\tconst resolutionTime = calculateIssueDuration(\n\t\t\t\tissue.createdAt,\n\t\t\t\tissue.updatedAt,\n\t\t\t);\n\n\t\t\t// Armazena informações sobre tempo de resolução\n\t\t\tbugResolutionTimes.push({\n\t\t\t\tnumber: issue.number,\n\t\t\t\ttitle: issue.title,\n\t\t\t\tresolutionDays: resolutionTime,\n\t\t\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\t\t});\n\t\t} else {\n\t\t\tpendingBugPoints += estimate;\n\t\t}\n\n\t\t// Organiza bugs por status\n\t\tif (!bugsByStatus[status]) {\n\t\t\tbugsByStatus[status] = [];\n\t\t}\n\t\tbugsByStatus[status].push({\n\t\t\ttitle: issue.title || 'Sem título',\n\t\t\tnumber: issue.number || 0,\n\t\t\turl: issue.url || '#',\n\t\t\tstate: issue.state || 'UNKNOWN',\n\t\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\t\tpriority: priority,\n\t\t\testimate: estimate,\n\t\t});\n\n\t\t// Organiza bugs por prioridade\n\t\tif (!bugsByPriority[priority]) {\n\t\t\tbugsByPriority[priority] = [];\n\t\t}\n\t\tbugsByPriority[priority].push({\n\t\t\ttitle: issue.title || 'Sem título',\n\t\t\tnumber: issue.number || 0,\n\t\t\turl: issue.url || '#',\n\t\t\tstate: issue.state || 'UNKNOWN',\n\t\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\t\tstatus: status,\n\t\t\testimate: estimate,\n\t\t});\n\t}\n\n\t// Rastreia bugs por prioridade\n\tif (isBug) {\n\t\tif (!bugsByPriority[priority]) {\n\t\t\tbugsByPriority[priority] = [];\n\t\t}\n\t\tbugsByPriority[priority].push({\n\t\t\ttitle: issue.title || 'Sem título',\n\t\t\tnumber: issue.number || 0,\n\t\t\turl: issue.url || '#',\n\t\t\tstate: issue.state || 'UNKNOWN',\n\t\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\t\testimate: estimate,\n\t\t});\n\t}\n\n\t// Conta por prioridade\n\tpriorityCounts[priority] = (priorityCounts[priority] || 0) + 1;\n\n\t// Conta por tipo de issue (usa o tipo do content ou o tipo de campo, se disponível)\n\tconst actualIssueType = exists(issue.issueType) \n\t\t? issue.issueType.name \n\t\t: issueType;\n\t\n\t// Atualiza a contagem de tipos (apenas uma vez por issue)\n\tissueTypeCounts[actualIssueType] = \n\t\t(issueTypeCounts[actualIssueType] || 0) + 1;\n\n\t// Conta por sprint\n\tif (sprint !== 'No Sprint') {\n\t\tsprintCounts[sprint] = (sprintCounts[sprint] || 0) + 1;\n\t}\n\n\t// Agrupa issues por status\n\tif (!issuesByStatus[status]) {\n\t\tissuesByStatus[status] = [];\n\t}\n\n\t// Adiciona a issue ao grupo correspondente\n\tissuesByStatus[status].push({\n\t\ttitle: issue.title || 'Sem título',\n\t\tnumber: issue.number || 0,\n\t\turl: issue.url || '#',\n\t\tstate: issue.state || 'UNKNOWN',\n\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\tlabels: issue.labels?.nodes?.map((l) => l.name) || [],\n\t\tpriority: priority,\n\t\tissueType: exists(issue.issueType) ? issue.issueType.name : issueType, // Prioriza o tipo do objeto content\n\t\tsprint: sprint,\n\t\testimate: estimate, // Adicionando a pontuação/estimativa da issue\n\t\tsprintStartDate: sprintStartDate,\n\t\tsprintEndDate: sprintStartDate\n\t\t\t? calculateEndDate(sprintStartDate, sprintDuration)\n\t\t\t: null,\n\t\tupdatedAt: issue.updatedAt || '',\n\t\tcreatedAt: issue.createdAt || '',\n\t});\n\n\t// Conta por responsável e soma estimativas por responsável\n\tif (exists(issue.assignees?.nodes)) {\n\t\tissue.assignees.nodes.forEach((assignee) => {\n\t\t\tif (assignee && assignee.login) {\n\t\t\t\tconst login = assignee.login;\n\n\t\t\t\t// Conta o número de issues\n\t\t\t\tassigneeCounts[login] = (assigneeCounts[login] || 0) + 1;\n\n\t\t\t\t// Conta o número de bugs por usuário\n\t\t\t\tif (isBug) {\n\t\t\t\t\tassigneeBugCounts[login] = (assigneeBugCounts[login] || 0) + 1;\n\t\t\t\t}\n\n\t\t\t\t// Soma as estimativas por usuário\n\t\t\t\tif (!assigneeEstimates[login]) {\n\t\t\t\t\tassigneeEstimates[login] = {\n\t\t\t\t\t\ttotal: 0, // Total de pontos\n\t\t\t\t\t\tdelivered: 0, // Pontos entregues (issues fechadas)\n\t\t\t\t\t\tpending: 0, // Pontos pendentes (issues abertas)\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Calcula pontos entregues vs. pendentes por usuário\n\t\t\t\tif (issue.state === 'CLOSED') {\n\t\t\t\t\tassigneeEstimates[login].delivered += estimate;\n\t\t\t\t} else {\n\t\t\t\t\tassigneeEstimates[login].pending += estimate;\n\t\t\t\t}\n\n\t\t\t\tassigneeEstimates[login].total += estimate;\n\n\t\t\t\t// Contagem por status para cada usuário\n\t\t\t\tif (!assigneeStatusCounts[login]) {\n\t\t\t\t\tassigneeStatusCounts[login] = {};\n\t\t\t\t}\n\t\t\t\tassigneeStatusCounts[login][status] =\n\t\t\t\t\t(assigneeStatusCounts[login][status] || 0) + 1;\n\n\t\t\t\t// Detalhes avançados por usuário\n\t\t\t\tif (!assigneeDetails[login]) {\n\t\t\t\t\tassigneeDetails[login] = {\n\t\t\t\t\t\tissues: [],\n\t\t\t\t\t\ttotalEstimate: 0,\n\t\t\t\t\t\ttotalBugs: 0, // Total de bugs\n\t\t\t\t\t\tstatusBreakdown: {},\n\t\t\t\t\t\tpriorityBreakdown: {},\n\t\t\t\t\t\ttypeBreakdown: {}, // Adicionando contagem por tipo de issue\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Adiciona a issue aos detalhes do usuário\n\t\t\t\tassigneeDetails[login].issues.push({\n\t\t\t\t\ttitle: issue.title || 'Sem título',\n\t\t\t\t\tnumber: issue.number || 0,\n\t\t\t\t\turl: issue.url || '#',\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tpriority: priority,\n\t\t\t\t\tissueType: exists(issue.issueType) ? issue.issueType.name : issueType, // Prioriza o tipo do objeto content\n\t\t\t\t\testimate: estimate,\n\t\t\t\t});\n\n\t\t\t\t// Atualiza estatísticas\n\t\t\t\tassigneeDetails[login].totalEstimate += estimate;\n\n\t\t\t\t// Incrementa o contador de bugs se a issue for um bug\n\t\t\t\tif (isBug) {\n\t\t\t\t\tassigneeDetails[login].totalBugs += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// Soma as estimativas totais\n\tif (exists(issue.estimate)) {\n\t\ttotalEstimatePoints += parseFloat(issue.estimate);\n\t}\n\n\t// Soma as estimativas por status\n\tif (!estimateTotals[status]) {\n\t\testimateTotals[status] = 0;\n\t}\n\testimateTotals[status] += exists(issue.estimate)\n\t\t? parseFloat(issue.estimate)\n\t\t: 0;\n});\n\n// Cria o resumo\nconst summary = {\n\tprojectTitle: projectData.title,\n\ttotalIssues: currentSprintItems.length,\n\tstatusCounts: statusCounts,\n\tpriorityCounts: priorityCounts,\n\tissueTypeCounts: issueTypeCounts, // Contagem por tipo de issue\n\tbugCount: bugCount, // Contador específico para bugs\n\tassigneeCounts: assigneeCounts,\n\tassigneeBugCounts: assigneeBugCounts, // Número de bugs por usuário\n\n\t// Calcula a proporção de bugs por usuário (quanto maior, pior a qualidade)\n\tassigneeBugRatio: Object.keys(assigneeCounts).reduce((acc, login) => {\n\t\tconst totalIssues = assigneeCounts[login] || 0;\n\t\tconst totalBugs = assigneeBugCounts[login] || 0;\n\t\tacc[login] =\n\t\t\ttotalIssues > 0 ? Math.round((totalBugs / totalIssues) * 100) : 0;\n\t\treturn acc;\n\t}, {}),\n\n\tassigneeEstimates: assigneeEstimates, // Adicionando as estimativas por usuário\n\tassigneeStatusCounts: assigneeStatusCounts, // Contagem de issues por status por usuário\n\t//assigneeDetails: assigneeDetails, // Detalhes detalhados por usuário - menos informação\n\t//sprintCounts: sprintCounts, //remove to reduce the information size\n\testimateTotals: estimateTotals,\n\ttotalEstimatePoints: totalEstimatePoints,\n\tcurrentSprint: currentSprint,\n\t//issuesByStatus: issuesByStatus, //remove to reduce the information size\n\tdate: new Date().toISOString(),\n\n\t// Contadores adicionais úteis\n\topenIssues: currentSprintItems.filter(\n\t\t(item) => item.content?.state === 'OPEN',\n\t).length,\n\tclosedIssues: currentSprintItems.filter(\n\t\t(item) => item.content?.state === 'CLOSED',\n\t).length,\n\n\t// Metadados da filtragem\n\tfilteredBySprint: Boolean(currentSprintId),\n\ttotalUnfilteredIssues: items.length,\n\n\t// Estimativas\n\ttotalEstimatePoints: totalEstimatePoints,\n\testimateTotals: estimateTotals,\n\n\t// Estatísticas de entrega\n\tdeliveredPoints: deliveredPoints, // Total de pontos já entregues (issues fechadas)\n\tpendingPoints: pendingPoints, // Total de pontos ainda não entregues\n\tpendingPercentage:\n\t\ttotalEstimatePoints > 0\n\t\t\t? Math.round((pendingPoints / totalEstimatePoints) * 100)\n\t\t\t: 0, // Porcentagem pendente\n\tdeliveredPercentage:\n\t\ttotalEstimatePoints > 0\n\t\t\t? Math.round((deliveredPoints / totalEstimatePoints) * 100)\n\t\t\t: 0, // Porcentagem entregue\n\n\t// Estatísticas de bugs\n\tbugPercentage:\n\t\tcurrentSprintItems.length > 0\n\t\t\t? Math.round((bugCount / currentSprintItems.length) * 100)\n\t\t\t: 0, // Porcentagem de bugs em relação ao total de issues\n\tbugResolutionRate:\n\t\tbugCount > 0 ? Math.round((deliveredBugCount / bugCount) * 100) : 0, // Taxa de resolução de bugs (porcentagem de bugs fechados)\n\t//bugsByStatus: bugsByStatus, // Bugs organizados por status\n\t//bugsByPriority: bugsByPriority, // Bugs organizados por prioridade\n\tpendingBugCount: pendingBugCount, // Número de bugs pendentes\n\tdeliveredBugCount: deliveredBugCount, // Número de bugs entregues\n\tassigneeBugCounts: assigneeBugCounts, // Número de bugs por usuário\n\n\t// Estatísticas de tempo de resolução de bugs\n\t// bugResolution: {\n\t// \ttimes: bugResolutionTimes,\n\t// \taverageResolutionDays:\n\t// \t\tbugResolutionTimes.length > 0\n\t// \t\t\t? Math.round(\n\t// \t\t\t\t\tbugResolutionTimes.reduce(\n\t// \t\t\t\t\t\t(sum, bug) => sum + bug.resolutionDays,\n\t// \t\t\t\t\t\t0,\n\t// \t\t\t\t\t) / bugResolutionTimes.length,\n\t// \t\t\t  )\n\t// \t\t\t: 0,\n\t// \tmaxResolutionDays:\n\t// \t\tbugResolutionTimes.length > 0\n\t// \t\t\t? Math.max(...bugResolutionTimes.map((bug) => bug.resolutionDays))\n\t// \t\t\t: 0,\n\t// \tminResolutionDays:\n\t// \t\tbugResolutionTimes.length > 0\n\t// \t\t\t? Math.min(...bugResolutionTimes.map((bug) => bug.resolutionDays))\n\t// \t\t\t: 0,\n\t// },\n};\n\n// Suporta ambos os ambientes (local e n8n)\nif (typeof module !== 'undefined' && module.exports) {\n\tconst fs = require('fs');\n\tfs.writeFileSync('./analysis_result.json', JSON.stringify(summary, null, 2));\n\tconsole.log({ json: summary }); // Exibe no console para visualização\n\tmodule.exports = { json: summary }; // Exporta para importação por outros módulos\n} else {\n\treturn { json: summary }; // n8n\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        -20
      ],
      "id": "9471a5a4-ff82-4066-af7a-719c0c562ea6",
      "name": "process_data"
    },
    {
      "parameters": {
        "jsCode": "const SOURCE_NODE_NAME = \"Get Data\"; // Nome do nó de origem\nconst MAX_ITERATIONS = 20; // Número máximo de iterações para prevenir loops infinitos\n\n// Array para armazenar todos os nós combinados\nlet allNodes = [];\nlet projectData = null;\nlet totalPagesProcessed = 0;\n\nconsole.log(`Iniciando coleta de dados de múltiplas execuções do nó: ${SOURCE_NODE_NAME}`);\n\n// Loop para coletar todas as saídas disponíveis\nlet iteration = 0;\nlet hasMoreData = true;\n\nwhile (hasMoreData && iteration < MAX_ITERATIONS) {\n  try {\n    // Tenta obter os dados da iteração atual\n    const pages = $items(SOURCE_NODE_NAME, 0, iteration);\n    \n    if (!pages || pages.length === 0) {\n      console.log(`Nenhum dado encontrado na iteração ${iteration}. Finalizando coleta.`);\n      hasMoreData = false;\n      continue;\n    }\n\n    console.log(`Processando dados da iteração ${iteration}. Encontrados ${pages.length} itens.`);\n    \n    // Processa cada item encontrado na iteração\n    for (const item of pages) {\n      // Verifica se temos os dados no formato esperado\n      const project = item.json?.data?.organization?.projectV2;\n      const nodes = project?.items?.nodes;\n      \n      if (project && nodes) {\n        // Se ainda não temos metadados do projeto, salvamos da primeira ocorrência válida\n        if (!projectData) {\n          projectData = project;\n          console.log(`Metadados do projeto obtidos: ${project.title} (ID: ${project.id})`);\n        }\n        \n        // Adiciona os nós encontrados ao array principal\n        console.log(`Adicionando ${nodes.length} novos itens ao conjunto de dados`);\n        allNodes.push(...nodes);\n        totalPagesProcessed++;\n      } else {\n        console.log(`Aviso: Formato de dados inesperado na iteração ${iteration}`);\n      }\n    }\n    \n    // Avança para a próxima iteração\n    iteration++;\n\n  } catch (error) {\n    // Se ocorrer um erro, significa que não há mais dados disponíveis\n    console.log(`Fim dos dados disponíveis após ${iteration} iterações. Erro: ${error.message}`);\n    hasMoreData = false;\n  }\n}\n\n// Verifica se conseguimos coletar algum dado\nif (!projectData || allNodes.length === 0) {\n  console.error(\"Erro: Nenhum dado válido foi encontrado em qualquer iteração\");\n  return [{\n    json: {\n      error: true,\n      message: \"Não foi possível coletar dados válidos\"\n    }\n  }];\n}\n\n// Estatísticas finais\nconsole.log(`Coleta de dados concluída:`);\nconsole.log(`- Total de iterações processadas: ${iteration}`);\nconsole.log(`- Total de páginas válidas: ${totalPagesProcessed}`);\nconsole.log(`- Total de itens coletados: ${allNodes.length}`);\nconsole.log(`- Dados do projeto: ${projectData.title} (ID: ${projectData.id})`);\n\n// Constrói o resultado final no formato esperado pelo process_data.js\nconst result = {\n  data: {\n    organization: {\n      projectV2: {\n        id: projectData.id,\n        title: projectData.title,\n        fields: projectData.fields,\n        items: {\n          nodes: allNodes,\n        },\n      },\n    },\n  },\n};\n\n// Retorna o resultado consolidado\nreturn [{ json: result }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        840,
        -20
      ],
      "id": "839c5f53-ea8f-4c2a-b70a-858dace6ce04",
      "name": "Combine Items",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        440,
        -40
      ],
      "id": "059a0514-5e89-40b6-a933-99d74b6b63d0",
      "name": "Wait",
      "webhookId": "740192a4-0412-4159-bcf6-6e10d0c7cccf"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0e2e5b28-0ae4-4f67-9eb5-2a9d1523c712",
              "leftValue": "={{ $json[\"data\"][\"organization\"][\"projectV2\"][\"items\"]['pageInfo']['hasNextPage'] }}",
              "rightValue": "=true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        640,
        -40
      ],
      "id": "5610369d-14f8-4fe2-9d1e-906d75254df0",
      "name": "Has new page?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b49c3f98-b7ed-457d-863f-34af97f08861",
              "name": "cursor",
              "value": "={{$json[\"data\"][\"organization\"][\"projectV2\"][\"items\"][\"pageInfo\"][\"endCursor\"]}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        640,
        -240
      ],
      "id": "aea5ec4e-a4ab-4c41-9fac-bb4fcb12e143",
      "name": "Set Next Page"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.github.com/graphql",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"query($organization: String!, $projectNumber: Int!, $afterCursor: String) { organization(login: $organization) { projectV2(number: $projectNumber) { id title fields(first: 20) { nodes { ... on ProjectV2Field { id name dataType } ... on ProjectV2IterationField { id name configuration { completedIterations { id title startDate duration } iterations { id title startDate duration } duration startDay } } ... on ProjectV2SingleSelectField { id name options { id name } } } } items(first: 100, after: $afterCursor) { pageInfo { hasNextPage endCursor } nodes { id content { ... on Issue { title number state url assignees(first: 5) { nodes { login } } labels(first: 5) { nodes { name } } issueType { id name } updatedAt createdAt } ... on PullRequest { title number state url assignees(first: 5) { nodes { login } } labels(first: 5) { nodes { name } } updatedAt createdAt } } fieldValues(first: 20) { nodes { ... on ProjectV2ItemFieldSingleSelectValue { name field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldDateValue { date field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldIterationValue { title startDate duration iterationId field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldNumberValue { number field { ... on ProjectV2FieldCommon { name } } } } } } } } } } }\",\n  \"variables\": {\n    \"afterCursor\": \"{{ $json.cursor ? $json.cursor : null }}\",\n    \"organization\": \"{{ $(\"Set Params\").item.json.organization }}\",\n    \"projectNumber\": {{ Number($(\"Set Params\").item.json.projectNumber) }}\n  }\n}\n",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        220,
        -40
      ],
      "id": "7cd9e68d-5d3f-494e-a3b6-5a33e6ad7d30",
      "name": "Get Data",
      "executeOnce": false,
      "credentials": {
        "githubApi": {
          "id": "leqgDcgVWMXdmn3K",
          "name": "GitHub account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Função auxiliar para verificar se um valor existe\nfunction exists(value) {\n\treturn value !== null && value !== undefined;\n}\n\n// Tenta obter os dados do processamento anterior de forma robusta\nlet summary;\n\n// Tenta várias estruturas possíveis\nif (exists($input)) {\n\tif (exists($input.json)) {\n\t\tif (Array.isArray($input.json) && $input.json.length > 0) {\n\t\t\tsummary = $input.json[0]; // Caso seja um array\n\t\t} else {\n\t\t\tsummary = $input.json; // Caso seja um objeto direto\n\t\t}\n\t} else if (exists($input.item) && exists($input.item.json)) {\n\t\tsummary = $input.item.json; // Estrutura comum em n8n\n\t} else {\n\t\tsummary = $input; // Último recurso\n\t}\n}\n\n// Se ainda não encontramos dados úteis\nif (\n\t!exists(summary) ||\n\t(!exists(summary.issuesByStatus) && !exists(summary.statusCounts))\n) {\n\treturn {\n\t\tjson: {\n\t\t\terror: true,\n\t\t\tmessage: 'Não foi possível obter os dados do processamento anterior',\n\t\t\tinputStructure: JSON.stringify($input).substring(0, 500) + '...',\n\t\t},\n\t};\n}\n\n// Formatar a data atual\nconst dateOptions = {\n\tweekday: 'long',\n\tday: 'numeric',\n\tmonth: 'long',\n\tyear: 'numeric',\n};\nconst today = new Date();\nconst formattedDate = today.toLocaleDateString('pt-BR', dateOptions);\n\n// Criar estatísticas rápidas\nconst quickStats = [];\n\n// Contador por status\nif (summary.statusCounts) {\n\tconst statusRows = Object.entries(summary.statusCounts)\n\t\t.map(\n\t\t\t([status, count]) =>\n\t\t\t\t`<tr><td>${status}</td><td align=\"center\"><b>${count}</b></td></tr>`,\n\t\t)\n\t\t.join('');\n\n\tquickStats.push(`\n    <div class=\"stat-card\">\n      <h3>Status</h3>\n      <table class=\"stats-table\">\n        <tr><th>Status</th><th>Quantidade</th></tr>\n        ${statusRows}\n      </table>\n    </div>\n  `);\n}\n\n// Contador por prioridade\nif (summary.priorityCounts) {\n\tconst priorityRows = Object.entries(summary.priorityCounts)\n\t\t.map(\n\t\t\t([priority, count]) =>\n\t\t\t\t`<tr><td>${priority}</td><td align=\"center\"><b>${count}</b></td></tr>`,\n\t\t)\n\t\t.join('');\n\n\tquickStats.push(`\n    <div class=\"stat-card\">\n      <h3>Prioridade</h3>\n      <table class=\"stats-table\">\n        <tr><th>Prioridade</th><th>Quantidade</th></tr>\n        ${priorityRows}\n      </table>\n    </div>\n  `);\n}\n\n// Contador por responsável\nif (summary.assigneeCounts) {\n\tconst assigneeRows = Object.entries(summary.assigneeCounts)\n\t\t.map(\n\t\t\t([assignee, count]) =>\n\t\t\t\t`<tr><td>${assignee}</td><td align=\"center\"><b>${count}</b></td></tr>`,\n\t\t)\n\t\t.join('');\n\n\tquickStats.push(`\n    <div class=\"stat-card\">\n      <h3>Responsáveis</h3>\n      <table class=\"stats-table\">\n        <tr><th>Responsável</th><th>Quantidade</th></tr>\n        ${assigneeRows}\n      </table>\n    </div>\n  `);\n}\n\n// Contador por tipo de issue\nif (summary.issueTypeCounts) {\n\tconst typeRows = Object.entries(summary.issueTypeCounts)\n\t\t.map(\n\t\t\t([type, count]) =>\n\t\t\t\t`<tr><td>${type}</td><td align=\"center\"><b>${count}</b></td></tr>`,\n\t\t)\n\t\t.join('');\n\n\tquickStats.push(`\n    <div class=\"stat-card\">\n      <h3>Tipos de Issues</h3>\n      <table class=\"stats-table\">\n        <tr><th>Tipo</th><th>Quantidade</th></tr>\n        ${typeRows}\n      </table>\n    </div>\n  `);\n}\n\n// Adicionar estatísticas de pontos estimados e entregues\nif (exists(summary.deliveredPoints) && exists(summary.pendingPoints)) {\n\tquickStats.push(`\n    <div class=\"stat-card\">\n      <h3>Progresso da Sprint</h3>\n      <table class=\"stats-table\">\n        <tr><th>Métrica</th><th>Valor</th></tr>\n        <tr><td>Pontos Entregues</td><td align=\"center\"><b>${summary.deliveredPoints}</b> (${summary.deliveredPercentage}%)</td></tr>\n        <tr><td>Pontos Pendentes</td><td align=\"center\"><b>${summary.pendingPoints}</b> (${summary.pendingPercentage}%)</td></tr>\n        <tr><td>Total de Pontos</td><td align=\"center\"><b>${summary.totalEstimatePoints}</b></td></tr>\n      </table>\n    </div>\n  `);\n}\n\n// Criar detalhes de cada status por assignee\nlet statusDetails = '';\n\n// Se temos os dados detalhados dos responsáveis\nif (summary.assigneeDetails) {\n\tstatusDetails += '<h2>Detalhes por Responsável</h2>';\n\n\tObject.entries(summary.assigneeDetails).forEach(([assignee, data]) => {\n\t\tif (!data.issues || data.issues.length === 0) return;\n\n\t\tstatusDetails += `\n          <div class=\"status-section\">\n            <h3>${assignee} <span class=\"count\">(${data.issues.length} issues, ${data.totalEstimate} pontos)</span></h3>\n            <table class=\"issue-table\">\n              <tr>\n                <th>Issue</th>\n                <th>Status</th>\n                <th>Prioridade</th>\n                <th>Estimativa</th>\n              </tr>\n        `;\n\n\t\t// Listar issues do responsável\n\t\tdata.issues.forEach((issue) => {\n\t\t\t// Verificar se é um objeto completo\n\t\t\tif (!exists(issue) || !exists(issue.title)) {\n\t\t\t\treturn; // Pular issues incompletas\n\t\t\t}\n\n\t\t\t// Determinar a cor da linha baseada na prioridade\n\t\t\tlet rowClass = '';\n\t\t\tif (issue.priority === 'P0') rowClass = 'priority-highest';\n\t\t\telse if (issue.priority === 'P1') rowClass = 'priority-high';\n\n\t\t\t// Adicionar linha da issue\n\t\t\tstatusDetails += `\n                <tr class=\"${rowClass}\">\n                  <td><a href=\"${issue.url || '#'}\" target=\"_blank\">#${\n\t\t\t\tissue.number || '?'\n\t\t\t}: ${issue.title}</a></td>\n                  <td align=\"center\">${issue.status || 'N/A'}</td>\n                  <td align=\"center\">${issue.priority || 'N/A'}</td>\n                  <td align=\"center\">${issue.estimate || 'N/A'}</td>\n                </tr>\n            `;\n\t\t});\n\n\t\t// Adicionar resumo de status\n\t\tif (data.statusBreakdown) {\n\t\t\tstatusDetails += `\n                <tr class=\"status-summary\">\n                  <td colspan=\"4\">\n                    <strong>Resumo por Status:</strong>\n                    ${Object.entries(data.statusBreakdown)\n\t\t\t\t\t\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t\t\t\t\t\t([status, info]) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${status}: ${info.count || 0} issues (${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo.points || 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t} pontos)`,\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t.join(', ')}\n                  </td>\n                </tr>\n            `;\n\t\t}\n\n\t\tstatusDetails += `\n            </table>\n          </div>\n        `;\n\t});\n}\n\n// Compatibilidade com o formato antigo, se disponível\nelse if (summary.issuesByStatus) {\n\tObject.entries(summary.issuesByStatus).forEach(([status, issues]) => {\n\t\t// Pular se não houver issues\n\t\tif (!issues || !issues.length) return;\n\n\t\t// Cabeçalho do status\n\t\tstatusDetails += `\n      <div class=\"status-section\">\n        <h2>${status} <span class=\"count\">(${issues.length})</span></h2>\n        <table class=\"issue-table\">\n          <tr>\n            <th>Issue</th>\n            <th>Prioridade</th>\n            <th>Estado</th>\n            <th>Responsáveis</th>\n            <th>Última atualização</th>\n          </tr>\n    `;\n\n\t\t// Listar as issues\n\t\tissues.forEach((issue) => {\n\t\t\t// Verificar se é um objeto completo\n\t\t\tif (!exists(issue) || !exists(issue.title)) {\n\t\t\t\treturn; // Pular issues incompletas\n\t\t\t}\n\n\t\t\t// Determinar a cor da linha baseada na prioridade\n\t\t\tlet rowClass = '';\n\t\t\tif (issue.priority === 'P0') rowClass = 'priority-highest';\n\t\t\telse if (issue.priority === 'P1') rowClass = 'priority-high';\n\n\t\t\t// Formatar data de atualização\n\t\t\tconst updatedDate = exists(issue.updatedAt)\n\t\t\t\t? new Date(issue.updatedAt).toLocaleDateString('pt-BR')\n\t\t\t\t: 'N/A';\n\n\t\t\t// Listar responsáveis\n\t\t\tconst assigneesList = Array.isArray(issue.assignees)\n\t\t\t\t? issue.assignees.join(', ')\n\t\t\t\t: '';\n\n\t\t\t// Adicionar linha da issue\n\t\t\tstatusDetails += `\n        <tr class=\"${rowClass}\">\n          <td><a href=\"${issue.url || '#'}\" target=\"_blank\">#${\n\t\t\t\tissue.number || '?'\n\t\t\t}: ${issue.title}</a></td>\n          <td align=\"center\">${issue.priority || 'N/A'}</td>\n          <td align=\"center\">${\n\t\t\t\t\t\tissue.state === 'OPEN' ? 'Aberta' : 'Fechada'\n\t\t\t\t\t}</td>\n          <td>${assigneesList}</td>\n          <td>${updatedDate}</td>\n        </tr>\n      `;\n\t\t});\n\n\t\tstatusDetails += `\n        </table>\n      </div>\n    `;\n\t});\n}\n\n// Montar o HTML final\nconst emailHtml = `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Resumo da Sprint: ${summary.projectTitle || 'Interlis Board'}</title>\n  <style>\n    body {\n      font-family: Arial, Helvetica, sans-serif;\n      line-height: 1.6;\n      color: #333;\n      max-width: 1000px;\n      margin: 0 auto;\n      padding: 20px;\n    }\n\n    h1 {\n      color: #205375;\n      border-bottom: 2px solid #205375;\n      padding-bottom: 10px;\n      margin-bottom: 30px;\n    }\n\n    h2 {\n      color: #2C74B3;\n      margin-top: 30px;\n      padding-bottom: 5px;\n      border-bottom: 1px solid #ddd;\n    }\n\n    h3 {\n      color: #0A2647;\n      margin-top: 0;\n    }\n\n    .count {\n      font-size: 0.8em;\n      color: #666;\n      font-weight: normal;\n    }\n\n    .stats-container {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 20px;\n      margin-bottom: 30px;\n    }\n\n    .stat-card {\n      flex: 1;\n      min-width: 250px;\n      background-color: #f9f9f9;\n      border-radius: 8px;\n      padding: 15px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    }\n\n    .stats-table {\n      width: 100%;\n      border-collapse: collapse;\n    }\n\n    .stats-table th, .stats-table td {\n      padding: 8px;\n      text-align: left;\n      border-bottom: 1px solid #ddd;\n    }\n\n    .stats-table th {\n      background-color: #f2f2f2;\n    }\n\n    .status-section {\n      margin-bottom: 40px;\n    }\n\n    .issue-table {\n      width: 100%;\n      border-collapse: collapse;\n      margin-top: 10px;\n    }\n\n    .issue-table th, .issue-table td {\n      padding: 10px;\n      border: 1px solid #ddd;\n    }\n\n    .issue-table th {\n      background-color: #f2f2f2;\n      text-align: left;\n    }\n\n    .issue-table tr:nth-child(even) {\n      background-color: #f9f9f9;\n    }\n\n    .status-summary {\n      background-color: #eef6ff !important;\n      font-size: 0.9em;\n    }\n\n    .priority-highest {\n      background-color: #ffeeee !important;\n    }\n\n    .priority-high {\n      background-color: #fff8e1 !important;\n    }\n\n    a {\n      color: #2C74B3;\n      text-decoration: none;\n    }\n\n    a:hover {\n      text-decoration: underline;\n    }\n\n    .date {\n      font-style: italic;\n      color: #666;\n      margin-bottom: 30px;\n    }\n\n    .summary-box {\n      background-color: #e9f5ff;\n      border-left: 4px solid #2C74B3;\n      padding: 15px;\n      margin-bottom: 30px;\n    }\n\n    .sprint-info {\n      background-color: #f0f8ff;\n      border-radius: 8px;\n      padding: 15px;\n      margin-bottom: 30px;\n      border: 1px solid #d1e3ff;\n    }\n\n    .progress-bar-container {\n      background-color: #eee;\n      border-radius: 5px;\n      margin: 10px 0;\n      height: 20px;\n    }\n\n    .progress-bar {\n      height: 20px;\n      background-color: #2C74B3;\n      border-radius: 5px;\n      color: white;\n      text-align: center;\n      line-height: 20px;\n      font-size: 12px;\n      font-weight: bold;\n    }\n\n    .mini-progress-bar-container {\n      background-color: #eee;\n      border-radius: 3px;\n      margin: 0;\n      height: 15px;\n      width: 100%;\n    }\n\n    .mini-progress-bar {\n      height: 15px;\n      background-color: #4CAF50;\n      border-radius: 3px;\n      color: white;\n      text-align: center;\n      line-height: 15px;\n      font-size: 11px;\n      font-weight: bold;\n    }\n\n    .footer {\n      margin-top: 50px;\n      border-top: 1px solid #ddd;\n      padding-top: 20px;\n      color: #666;\n      font-size: 0.9em;\n      text-align: center;\n    }\n\n    .mini-progress-bar-container {\n      background-color: #eee;\n      border-radius: 5px;\n      height: 10px;\n      width: 100%;\n      margin: 5px 0;\n    }\n\n    .mini-progress-bar {\n      height: 10px;\n      background-color: #2C74B3;\n      border-radius: 5px;\n      color: white;\n      text-align: center;\n      line-height: 10px;\n      font-size: 10px;\n      font-weight: bold;\n    }\n  </style>\n</head>\n<body>\n  <h1>Resumo da Sprint: ${summary.projectTitle || 'Interlis Board'}</h1>\n  <p class=\"date\">Relatório gerado em: ${formattedDate}</p>\n\n  ${\n\t\tsummary.currentSprint\n\t\t\t? `\n  <div class=\"sprint-info\">\n    <h3>Sprint ${summary.currentSprint.title}</h3>\n    <p><strong>Período:</strong> ${new Date(\n\t\t\tsummary.currentSprint.startDate,\n\t\t).toLocaleDateString('pt-BR')} a ${new Date(\n\t\t\t\t\tsummary.currentSprint.endDate,\n\t\t\t  ).toLocaleDateString('pt-BR')}</p>\n    <p><strong>Duração:</strong> ${summary.currentSprint.duration} dias</p>\n    <p><strong>Progresso:</strong></p>\n    <div class=\"progress-bar-container\">\n      <div class=\"progress-bar\" style=\"width: ${summary.deliveredPercentage}%\">\n        ${summary.deliveredPercentage}% Completo\n      </div>\n    </div>\n  </div>\n  `\n\t\t\t: ''\n\t}\n\n  <div class=\"summary-box\">\n    <p><strong>Total de issues:</strong> ${summary.totalIssues || 'N/A'}</p>\n    <p><strong>Issues abertas:</strong> ${summary.openIssues || 'N/A'}</p>\n    <p><strong>Issues fechadas:</strong> ${summary.closedIssues || 'N/A'}</p>\n    ${\n\t\t\tsummary.totalEstimatePoints\n\t\t\t\t? `<p><strong>Total de pontos:</strong> ${summary.totalEstimatePoints}</p>`\n\t\t\t\t: ''\n\t\t}\n    ${\n\t\t\tsummary.deliveredPoints\n\t\t\t\t? `<p><strong>Pontos entregues:</strong> ${summary.deliveredPoints} (${summary.deliveredPercentage}%)</p>`\n\t\t\t\t: ''\n\t\t}\n    ${\n\t\t\tsummary.pendingPoints\n\t\t\t\t? `<p><strong>Pontos pendentes:</strong> ${summary.pendingPoints} (${summary.pendingPercentage}%)</p>`\n\t\t\t\t: ''\n\t\t}\n    ${\n\t\t\tsummary.bugCount\n\t\t\t\t? `<p><strong>Total de bugs:</strong> ${summary.bugCount} (${summary.bugPercentage}% das issues)</p>`\n\t\t\t\t: ''\n\t\t}\n    ${\n\t\t\tsummary.deliveredBugCount\n\t\t\t\t? `<p><strong>Bugs resolvidos:</strong> ${summary.deliveredBugCount} (Taxa de resolução: ${summary.bugResolutionRate}%)</p>`\n\t\t\t\t: ''\n\t\t}\n    ${\n\t\t\tsummary.pendingBugCount\n\t\t\t\t? `<p><strong>Bugs pendentes:</strong> ${summary.pendingBugCount}</p>`\n\t\t\t\t: ''\n\t\t}\n  </div>\n\n  <div class=\"stats-container\">\n    ${quickStats.join('')}\n  </div>\n\n  ${\n\t\tsummary.assigneeBugCounts &&\n\t\tObject.keys(summary.assigneeBugCounts).length > 0\n\t\t\t? `\n  <h2>Distribuição de Bugs por Responsável</h2>\n  <div class=\"stats-container\">\n    <div class=\"stat-card\" style=\"flex: 2; min-width: 400px;\">\n      <h3>Contador de Bugs por Responsável</h3>\n      <table class=\"stats-table\">\n        <tr>\n          <th>Responsável</th>\n          <th>Bugs</th>\n          <th>% de Bugs</th>\n          <th>Total Issues</th>\n        </tr>\n        ${Object.entries(summary.assigneeBugCounts)\n\t\t\t\t\t.map(\n\t\t\t\t\t\t([assignee, count]) => `\n          <tr>\n            <td>${assignee}</td>\n            <td align=\"center\"><b>${count}</b></td>\n            <td align=\"center\">${summary.assigneeBugRatio[assignee] || 0}%</td>\n            <td align=\"center\">${summary.assigneeCounts[assignee] || 0}</td>\n          </tr>\n        `,\n\t\t\t\t\t)\n\t\t\t\t\t.join('')}\n      </table>\n    </div>\n  </div>\n  `\n\t\t\t: ''\n\t}\n\n  ${\n\t\tsummary.assigneeEstimates &&\n\t\tObject.keys(summary.assigneeEstimates).length > 0\n\t\t\t? `\n  <h2>Progresso por Responsável</h2>\n  <div class=\"stats-container\">\n    <div class=\"stat-card\" style=\"flex: 2; min-width: 400px;\">\n      <h3>Pontos por Responsável</h3>\n      <table class=\"stats-table\">\n        <tr>\n          <th>Responsável</th>\n          <th>Pontos Entregues</th>\n          <th>Pontos Pendentes</th>\n          <th>Total Pontos</th>\n          <th>% Conclusão</th>\n        </tr>\n        ${Object.entries(summary.assigneeEstimates)\n\t\t\t\t\t.filter(([_, data]) => data.total > 0)\n\t\t\t\t\t.map(([assignee, data]) => {\n\t\t\t\t\t\tconst completionPercentage =\n\t\t\t\t\t\t\tdata.total > 0\n\t\t\t\t\t\t\t\t? Math.round((data.delivered / data.total) * 100)\n\t\t\t\t\t\t\t\t: 0;\n\t\t\t\t\t\treturn `\n          <tr>\n            <td>${assignee}</td>\n            <td align=\"center\"><b>${data.delivered}</b></td>\n            <td align=\"center\">${data.pending}</td>\n            <td align=\"center\">${data.total}</td>\n            <td align=\"center\">\n              <div class=\"mini-progress-bar-container\">\n                <div class=\"mini-progress-bar\" style=\"width: ${completionPercentage}%\">\n                  ${completionPercentage}%\n                </div>\n              </div>\n            </td>\n          </tr>\n          `;\n\t\t\t\t\t})\n\t\t\t\t\t.join('')}\n      </table>\n    </div>\n  </div>\n  `\n\t\t\t: ''\n\t}\n\n  ${statusDetails}\n\n  <div class=\"footer\">\n    <p>Este relatório é gerado automaticamente pela automação n8n.</p>\n  </div>\n</body>\n</html>\n`;\n\n// Retornar o HTML formatado e o assunto do email\nreturn {\n\tjson: {\n\t\temailHtml: emailHtml,\n\t\tsubject: `Relatório Diário da Sprint: ${\n\t\t\tsummary.projectTitle || 'Interlis Board'\n\t\t} - ${today.toLocaleDateString('pt-BR')}`,\n\t},\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1220,
        -20
      ],
      "id": "af372b69-b20c-4eca-9fa3-f3177c9f8c20",
      "name": "format_mail"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "09e4a75e-5f5b-4028-a2fe-0519040a560f",
              "name": "organization",
              "value": "Interlis",
              "type": "string"
            },
            {
              "id": "99fcf2c6-5207-4413-9910-d6add30b3a3f",
              "name": "projectNumber",
              "value": 3,
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        40,
        -40
      ],
      "id": "22c7ad59-18e8-423c-80aa-405b3068222f",
      "name": "Set Params"
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Set Params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_data": {
      "main": [
        [
          {
            "node": "format_mail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Items": {
      "main": [
        [
          {
            "node": "process_data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Has new page?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has new page?": {
      "main": [
        [
          {
            "node": "Set Next Page",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Combine Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Next Page": {
      "main": [
        [
          {
            "node": "Get Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Data": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format_mail": {
      "main": [
        [
          {
            "node": "Gmail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Params": {
      "main": [
        [
          {
            "node": "Get Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8015a328-110b-4d4a-8c5c-fd71eaa5a94d",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "680b771266285e0b2805aa12c56e24ddd5aa291181c2c29d2ca50bff81261932"
  },
  "id": "fb8lGUgQlHG79Uwh",
  "tags": [
    {
      "createdAt": "2025-05-20T16:31:04.983Z",
      "updatedAt": "2025-05-20T16:31:04.983Z",
      "id": "YePntUlhLK5IUSTv",
      "name": "reports"
    },
    {
      "createdAt": "2025-05-20T16:31:25.865Z",
      "updatedAt": "2025-05-20T16:31:25.865Z",
      "id": "bnKivuIlYbm8QgCU",
      "name": "development"
    }
  ]
}