{
  "name": "Sprint Analysis",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "=0 6 * * 1-5"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        -40
      ],
      "id": "99b4cf7b-a7a0-41c6-9712-5f8318ff677d",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "sendTo": "george.farias@f4g.com.br",
        "subject": "={{$json[\"choices\"][0].message.content.subject}}",
        "message": "={{$json[\"choices\"][0].message.content.body}}",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        1920,
        -20
      ],
      "id": "3c14018b-bf2d-4927-bae1-c5d47d9adb19",
      "name": "Gmail",
      "webhookId": "6e29f7ad-c617-46fa-8dd2-c55e887cfe60",
      "credentials": {
        "gmailOAuth2": {
          "id": "9eY5yubWIBMcDRl1",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Função auxiliar para verificar se um valor existe\nfunction exists(value) {\n\treturn value !== null && value !== undefined;\n}\n\n// Função auxiliar para calcular a data de término de uma sprint\nfunction calculateEndDate(startDate, durationDays) {\n\tif (!startDate || !durationDays) return null;\n\n\tconst date = new Date(startDate);\n\tdate.setDate(date.getDate() + parseInt(durationDays) - 1); // Subtrair 1 porque a data de início já conta como dia 1\n\treturn date.toISOString().split('T')[0]; // Retorna apenas a parte da data (YYYY-MM-DD)\n}\n\nlet projectData,\n\titems = [];\n\n// Verifica se estamos em ambiente local\nif (typeof $input === 'undefined') {\n\tconsole.log('Ambiente local detectado, carregando data.json');\n\tconst fs = require('fs');\n\tlet localData = JSON.parse(fs.readFileSync('./data.json', 'utf8'));\n\n\t$input = {\n\t\titem: { json: localData[0] },\n\t};\n\tconsole.log('Arquivo data.json carregado com sucesso');\n}\n\ntry {\n\tprojectData = $input.item.json.data.organization.projectV2;\n\titems = projectData.items.nodes;\n} catch (error) {\n\treturn {\n\t\tjson: {\n\t\t\terror: true,\n\t\t\tmessage: `Erro ao processar dados: ${error.message}`,\n\t\t\tinputStructure: JSON.stringify($input).substring(0, 500) + '...',\n\t\t},\n\t};\n}\n\n// Inicializa contadores\nconst statusCounts = {};\nconst priorityCounts = {};\nconst assigneeCounts = {}; // Número de issues por usuário\nconst assigneeEstimates = {}; // Total de pontos por usuário\nconst assigneeStatusCounts = {}; // Contagem de issues por status por usuário\nconst assigneeDetails = {}; // Detalhes detalhados por usuário\nconst issuesByStatus = {};\nconst sprintCounts = {};\nconst estimateTotals = {}; // Para armazenar o total de pontos por status\nlet totalEstimatePoints = 0; // Total de pontos em todas as issues\nlet deliveredPoints = 0; // Total de pontos em issues fechadas\nlet pendingPoints = 0; // Total de pontos em issues ainda não fechadas\n\n// Armazena informações sobre sprints\nconst sprintInfo = {};\nlet currentSprint = null;\nlet currentSprintId = null;\n// Primeira passagem: Identifica a sprint atual\n// Precisamos fazer isso primeiro para depois filtrar apenas issues da sprint atual\nitems.forEach((item) => {\n\tif (!exists(item) || !exists(item.fieldValues?.nodes)) return;\n\n\titem.fieldValues.nodes.forEach((fieldValue) => {\n\t\tif (\n\t\t\t!exists(fieldValue) ||\n\t\t\t!exists(fieldValue.field) ||\n\t\t\tfieldValue.field.name !== 'Sprint' ||\n\t\t\t!exists(fieldValue.title)\n\t\t)\n\t\t\treturn;\n\n\t\tconst sprint = fieldValue.title;\n\t\tconst sprintId = fieldValue.iterationId;\n\t\tconst sprintStartDate = fieldValue.startDate;\n\t\tconst sprintDuration = fieldValue.duration;\n\n\t\t// Armazena informações da sprint\n\t\tif (!sprintInfo[sprintId]) {\n\t\t\tsprintInfo[sprintId] = {\n\t\t\t\ttitle: sprint,\n\t\t\t\tstartDate: sprintStartDate,\n\t\t\t\tduration: sprintDuration,\n\t\t\t\tendDate: calculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t};\n\t\t}\n\n\t\t// Determina a sprint atual com base na data\n\t\tconst today = new Date();\n\t\tconst sprintStart = new Date(sprintStartDate);\n\t\tconst sprintEnd = new Date(\n\t\t\tcalculateEndDate(sprintStartDate, sprintDuration),\n\t\t);\n\n\t\tif (today >= sprintStart && today <= sprintEnd) {\n\t\t\tcurrentSprint = sprintInfo[sprintId];\n\t\t\tcurrentSprintId = sprintId;\n\t\t}\n\t});\n});\n\n// Se não encontrou nenhuma sprint atual, usa a data atual para avisar\nif (!currentSprint) {\n\tconsole.log('Nenhuma sprint ativa no momento. Processando todos os itens.');\n} else {\n\tconsole.log(\n\t\t`Sprint atual identificada: ${currentSprint.title} (${currentSprint.startDate} a ${currentSprint.endDate})`,\n\t);\n}\n\n// Filtra apenas itens da sprint atual (se uma for encontrada)\nconst currentSprintItems = currentSprintId\n\t? items.filter((item) => {\n\t\t\tif (!exists(item) || !exists(item.fieldValues?.nodes)) return false;\n\n\t\t\t// Verifica se o item pertence à sprint atual\n\t\t\treturn item.fieldValues.nodes.some(\n\t\t\t\t(fieldValue) =>\n\t\t\t\t\texists(fieldValue) &&\n\t\t\t\t\texists(fieldValue.field) &&\n\t\t\t\t\tfieldValue.field.name === 'Sprint' &&\n\t\t\t\t\texists(fieldValue.iterationId) &&\n\t\t\t\t\tfieldValue.iterationId === currentSprintId,\n\t\t\t);\n\t  })\n\t: items; // Se não houver sprint atual, usa todos os itens\n\n// Log de informações de filtragem\nif (currentSprintId) {\n\tif (currentSprintItems.length === 0) {\n\t\tconsole.log(\n\t\t\t`Alerta: Não foram encontradas issues na sprint atual (${currentSprint.title})`,\n\t\t);\n\t} else {\n\t\tconsole.log(\n\t\t\t`Filtrando apenas itens da sprint atual: ${\n\t\t\t\tcurrentSprintItems.length\n\t\t\t} de ${items.length} itens (${Math.round(\n\t\t\t\t(currentSprintItems.length / items.length) * 100,\n\t\t\t)}%)`,\n\t\t);\n\t}\n} else {\n\tconsole.log(\n\t\t`Processando todos os ${items.length} itens, sem filtro de sprint.`,\n\t);\n}\n\n// Processa cada item da sprint atual\ncurrentSprintItems.forEach((item) => {\n\t// Pula itens sem conteúdo\n\tif (!exists(item) || !exists(item.content)) return;\n\n\tconst issue = item.content;\n\n\t// Valores padrão\n\tlet status = 'No Status';\n\tlet priority = 'No Priority';\n\tlet sprint = 'No Sprint';\n\tlet sprintId = null;\n\tlet sprintStartDate = null;\n\tlet sprintDuration = null;\n\tlet estimate = 0; // Valor padrão para estimativa/pontos\n\n\t// Tenta encontrar status e prioridade\n\tif (exists(item.fieldValues?.nodes)) {\n\t\titem.fieldValues.nodes.forEach((fieldValue) => {\n\t\t\tif (!exists(fieldValue) || !exists(fieldValue.field)) return;\n\n\t\t\tif (fieldValue.field.name === 'Status' && exists(fieldValue.name)) {\n\t\t\t\tstatus = fieldValue.name;\n\t\t\t}\n\t\t\tif (fieldValue.field.name === 'Priority' && exists(fieldValue.name)) {\n\t\t\t\tpriority = fieldValue.name;\n\t\t\t}\n\t\t\t// Captura o valor de estimativa/pontos\n\t\t\tif (fieldValue.field.name === 'Estimate' && exists(fieldValue.number)) {\n\t\t\t\testimate = parseFloat(fieldValue.number) || 0;\n\t\t\t}\n\t\t\t// Captura informações da sprint\n\t\t\tif (fieldValue.field.name === 'Sprint' && exists(fieldValue.title)) {\n\t\t\t\tsprint = fieldValue.title;\n\t\t\t\tsprintId = fieldValue.iterationId;\n\t\t\t\tsprintStartDate = fieldValue.startDate;\n\t\t\t\tsprintDuration = fieldValue.duration;\n\n\t\t\t\t// Armazena informações da sprint para uso posterior\n\t\t\t\tif (!sprintInfo[sprintId]) {\n\t\t\t\t\tsprintInfo[sprintId] = {\n\t\t\t\t\t\ttitle: sprint,\n\t\t\t\t\t\tstartDate: sprintStartDate,\n\t\t\t\t\t\tduration: sprintDuration,\n\t\t\t\t\t\tendDate: calculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Determina a sprint atual com base na data\n\t\t\t\tconst today = new Date();\n\t\t\t\tconst sprintStart = new Date(sprintStartDate);\n\t\t\t\tconst sprintEnd = new Date(\n\t\t\t\t\tcalculateEndDate(sprintStartDate, sprintDuration),\n\t\t\t\t);\n\n\t\t\t\tif (today >= sprintStart && today <= sprintEnd) {\n\t\t\t\t\tcurrentSprint = sprintInfo[sprintId];\n\t\t\t\t\tcurrentSprintId = sprintId;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// Conta por status\n\tstatusCounts[status] = (statusCounts[status] || 0) + 1;\n\n\t// Acumula pontos de estimativa por status\n\tif (!estimateTotals[status]) {\n\t\testimateTotals[status] = 0;\n\t}\n\testimateTotals[status] += estimate;\n\ttotalEstimatePoints += estimate;\n\t\n\t// Calcula pontos entregues vs. pontos pendentes\n\tif (issue.state === 'CLOSED') {\n\t\tdeliveredPoints += estimate;\n\t} else {\n\t\tpendingPoints += estimate;\n\t}\n\n\t// Conta por prioridade\n\tpriorityCounts[priority] = (priorityCounts[priority] || 0) + 1;\n\n\t// Conta por sprint\n\tif (sprint !== 'No Sprint') {\n\t\tsprintCounts[sprint] = (sprintCounts[sprint] || 0) + 1;\n\t}\n\n\t// Agrupa issues por status\n\tif (!issuesByStatus[status]) {\n\t\tissuesByStatus[status] = [];\n\t}\n\n\t// Adiciona a issue ao grupo correspondente\n\tissuesByStatus[status].push({\n\t\ttitle: issue.title || 'Sem título',\n\t\tnumber: issue.number || 0,\n\t\turl: issue.url || '#',\n\t\tstate: issue.state || 'UNKNOWN',\n\t\tassignees: issue.assignees?.nodes?.map((a) => a.login) || [],\n\t\tlabels: issue.labels?.nodes?.map((l) => l.name) || [],\n\t\tpriority: priority,\n\t\tsprint: sprint,\n\t\testimate: estimate, // Adicionando a pontuação/estimativa da issue\n\t\tsprintStartDate: sprintStartDate,\n\t\tsprintEndDate: sprintStartDate\n\t\t\t? calculateEndDate(sprintStartDate, sprintDuration)\n\t\t\t: null,\n\t\tupdatedAt: issue.updatedAt || '',\n\t\tcreatedAt: issue.createdAt || '',\n\t});\n\n\t// Conta por responsável e soma estimativas por responsável\n\tif (exists(issue.assignees?.nodes)) {\n\t\tissue.assignees.nodes.forEach((assignee) => {\n\t\t\tif (assignee && assignee.login) {\n\t\t\t\tconst login = assignee.login;\n\n\t\t\t\t// Conta o número de issues\n\t\t\t\tassigneeCounts[login] = (assigneeCounts[login] || 0) + 1;\n\n\t\t\t\t// Soma as estimativas por usuário\n\t\t\t\tif (!assigneeEstimates[login]) {\n\t\t\t\t\tassigneeEstimates[login] = {\n\t\t\t\t\t\ttotal: 0,      // Total de pontos\n\t\t\t\t\t\tdelivered: 0,  // Pontos entregues (issues fechadas)\n\t\t\t\t\t\tpending: 0     // Pontos pendentes (issues abertas)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Calcula pontos entregues vs. pendentes por usuário\n\t\t\t\tif (issue.state === 'CLOSED') {\n\t\t\t\t\tassigneeEstimates[login].delivered += estimate;\n\t\t\t\t} else {\n\t\t\t\t\tassigneeEstimates[login].pending += estimate;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tassigneeEstimates[login].total += estimate;\n\n\t\t\t\t// Contagem por status para cada usuário\n\t\t\t\tif (!assigneeStatusCounts[login]) {\n\t\t\t\t\tassigneeStatusCounts[login] = {};\n\t\t\t\t}\n\t\t\t\tassigneeStatusCounts[login][status] =\n\t\t\t\t\t(assigneeStatusCounts[login][status] || 0) + 1;\n\n\t\t\t\t// Detalhes avançados por usuário\n\t\t\t\tif (!assigneeDetails[login]) {\n\t\t\t\t\tassigneeDetails[login] = {\n\t\t\t\t\t\tissues: [],\n\t\t\t\t\t\ttotalEstimate: 0,\n\t\t\t\t\t\tstatusBreakdown: {},\n\t\t\t\t\t\tpriorityBreakdown: {},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Adiciona a issue aos detalhes do usuário\n\t\t\t\tassigneeDetails[login].issues.push({\n\t\t\t\t\ttitle: issue.title || 'Sem título',\n\t\t\t\t\tnumber: issue.number || 0,\n\t\t\t\t\turl: issue.url || '#',\n\t\t\t\t\tstatus: status,\n\t\t\t\t\tpriority: priority,\n\t\t\t\t\testimate: estimate,\n\t\t\t\t});\n\n\t\t\t\t// Atualiza estatísticas\n\t\t\t\tassigneeDetails[login].totalEstimate += estimate;\n\n\t\t\t\t// Status breakdown\n\t\t\t\tif (!assigneeDetails[login].statusBreakdown[status]) {\n\t\t\t\t\tassigneeDetails[login].statusBreakdown[status] = {\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tpoints: 0,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tassigneeDetails[login].statusBreakdown[status].count += 1;\n\t\t\t\tassigneeDetails[login].statusBreakdown[status].points += estimate;\n\n\t\t\t\t// Priority breakdown\n\t\t\t\tif (!assigneeDetails[login].priorityBreakdown[priority]) {\n\t\t\t\t\tassigneeDetails[login].priorityBreakdown[priority] = {\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tpoints: 0,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tassigneeDetails[login].priorityBreakdown[priority].count += 1;\n\t\t\t\tassigneeDetails[login].priorityBreakdown[priority].points += estimate;\n\t\t\t}\n\t\t});\n\t}\n\n\t// Soma as estimativas totais\n\tif (exists(issue.estimate)) {\n\t\ttotalEstimatePoints += parseFloat(issue.estimate);\n\t}\n\n\t// Soma as estimativas por status\n\tif (!estimateTotals[status]) {\n\t\testimateTotals[status] = 0;\n\t}\n\testimateTotals[status] += exists(issue.estimate)\n\t\t? parseFloat(issue.estimate)\n\t\t: 0;\n});\n\n// Cria o resumo\nconst summary = {\n\tprojectTitle: projectData.title,\n\ttotalIssues: currentSprintItems.length,\n\tstatusCounts: statusCounts,\n\tpriorityCounts: priorityCounts,\n\tassigneeCounts: assigneeCounts,\n\tassigneeEstimates: assigneeEstimates, // Adicionando as estimativas por usuário\n\tassigneeStatusCounts: assigneeStatusCounts, // Contagem de issues por status por usuário\n\tassigneeDetails: assigneeDetails, // Detalhes detalhados por usuário\n\t//sprintCounts: sprintCounts, //remove to reduce the information size\n\testimateTotals: estimateTotals,\n\ttotalEstimatePoints: totalEstimatePoints,\n\tcurrentSprint: currentSprint,\n\t//issuesByStatus: issuesByStatus, //remove to reduce the information size\n\tdate: new Date().toISOString(),\n\n\t// Contadores adicionais úteis\n\topenIssues: currentSprintItems.filter(\n\t\t(item) => item.content?.state === 'OPEN',\n\t).length,\n\tclosedIssues: currentSprintItems.filter(\n\t\t(item) => item.content?.state === 'CLOSED',\n\t).length,\n\n\t// Metadados da filtragem\n\tfilteredBySprint: Boolean(currentSprintId),\n\ttotalUnfilteredIssues: items.length,\n\n\t// Estimativas\n\ttotalEstimatePoints: totalEstimatePoints,\n\testimateTotals: estimateTotals,\n\t\n\t// Estatísticas de entrega\n\tdeliveredPoints: deliveredPoints, // Total de pontos já entregues (issues fechadas)\n\tpendingPoints: pendingPoints, // Total de pontos ainda não entregues\n\tpendingPercentage: totalEstimatePoints > 0 ? Math.round((pendingPoints / totalEstimatePoints) * 100) : 0, // Porcentagem pendente\n\tdeliveredPercentage: totalEstimatePoints > 0 ? Math.round((deliveredPoints / totalEstimatePoints) * 100) : 0, // Porcentagem entregue\n};\n\n// Suporta ambos os ambientes (local e n8n)\nif (typeof module !== 'undefined' && module.exports) {\n\tconst fs = require('fs');\n\tfs.writeFileSync('./analysis_result.json', JSON.stringify(summary, null, 2));\n\tconsole.log({ json: summary }); // Exibe no console para visualização\n\tmodule.exports = { json: summary }; // Exporta para importação por outros módulos\n} else {\n\treturn { json: summary }; // n8n\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        -20
      ],
      "id": "329b1955-dc23-485a-bff4-8e0fabfdb5ac",
      "name": "process_data"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "CHATGPT-4O-LATEST"
        },
        "messages": {
          "values": [
            {
              "content": "=Com base no JSON fornecido, aqui está a versão atualizada e otimizada do prompt para uso no n8n, com foco executivo e máximo de inteligência extraída dos dados:\n\n---\n\n## ✅ Prompt Final Atualizado:\n\n````plaintext\nVocê é um analista sênior de projetos ágeis.\n\nReceberá abaixo um JSON com informações detalhadas sobre uma sprint em andamento. Sua tarefa é gerar uma **análise executiva inteligente e visual**, formatada em HTML, para envio diário por e-mail.\n\n🎯 A saída esperada é um JSON com os campos:\n\n```json\n{\n  \"subject\": \"Análise da Sprint {{ $json.currentSprint.title }}\",\n  \"body\": \"<conteúdo HTML completo>\"\n}\n````\n\n---\n\n📌 **INSTRUÇÕES DO CAMPO `body` (HTML):**\n\n- Use HTML estruturado com `<h2>`, `<h3>`, `<p>`, `<ul>`, `<li>`, `<strong>` e emojis.\n- A linguagem deve ser executiva, clara e orientada a decisões.\n- Divida o conteúdo nas seguintes seções:\n\n---\n\n### 1. 📊 Visão Geral\n\n- Nome do projeto: **{{ $json.projectTitle }}**\n- Total de issues: **{{ $json.totalIssues }}**\n- Issues abertas: **{{ $json.openIssues }}**, entregues: **{{ $json.closedIssues }}**\n- Percentual entregue: **{{ $json.deliveredPercentage }}%**\n- Percentual pendente: **{{ $json.pendingPercentage }}%**\n- Pontos entregues: **{{ $json.deliveredPoints }}**\n- Pontos pendentes: **{{ $json.pendingPoints }}**\n- Pontuação total da sprint: **{{ $json.totalEstimatePoints }}**\n- Dias úteis restantes (com base nas datas da sprint e no campo `date`)\n- Status predominante entre as issues pendentes (ex: maior número entre Ready, Test, In Progress)\n\n---\n\n### 2. ⚠️ Riscos e Gargalos\n\n- Total de tarefas bloqueadas: **{{ $json.statusCounts.Blocked || 0 }}**\n- Tarefas sem responsável (analisar se existem no JSON)\n- Tarefas em status intermediário que demandam atenção:\n\n  - Waiting Evidence: **{{ $json.statusCounts[\"Waiting Evidence\"] || 0 }}**\n  - In Review: **{{ $json.statusCounts[\"In review\"] || 0 }}**\n  - Test: **{{ $json.statusCounts[\"Test\"] || 0 }}**\n\n- Tarefas com estimativa alta ainda não iniciadas (`Ready` com mais de 50% dos pontos)\n- Sinalizar transbordos se presentes nos labels\n\n---\n\n### 3. 🐞 Qualidade e Bugs\n\n- Total de issues com **bug** (verificar por `BUG` no título ou `label`)\n- Total de issues com **retrabalho** (por label `retrabalho`)\n- Concentração de urgência:\n\n  - P0: **{{ $json.priorityCounts.P0 }}**\n  - P1: **{{ $json.priorityCounts.P1 }}**\n\n- Alerta se P0 + P1 for maior que 50% das prioridades\n\n---\n\n### 4. 👥 Performance da Equipe\n\n- Liste os membros por ordem decrescente de pontos **entregues** (usar `assigneeEstimates`)\n- Destaque:\n\n  - Membro com maior entrega (mais pontos entregues)\n  - Membros com alta carga e baixa entrega (alto `pending`, baixo `delivered`)\n  - Membros com zero entrega até o momento\n\n- **Ignore os membros:** `DanielleVilarinho`, `alisonbarros`, `georgesouzafarias`\n- Apontar desequilíbrio na distribuição\n\n---\n\n### 5. 🧭 Recomendações\n\n- Ações práticas para:\n\n  - Redistribuir tarefas pendentes\n  - Remover bloqueios\n  - Melhorar cobertura de testes\n  - Reduzir gargalos\n  - Reforçar suporte aos membros com alta carga e baixa entrega\n\n- Indicar tarefas críticas que devem ser priorizadas até o final da sprint\n\n---\n\n📦 JSON da Sprint será passado via `{{ JSON.stringify($json, null, 2) }}`\n\n💡 Dicas extras:\n\n- Utilize emojis para destacar partes importantes\n- Não inclua assinatura ou saudação\n- Uma issue só é considerada entregue se estiver em `\"Test Done\"`, `\"Deployed to Staging\"` ou `\"Deployed to Production\"`\n- Seja direto e com foco em execução\n",
              "role": "assistant"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {
          "maxTokens": null,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1540,
        -20
      ],
      "id": "6f333283-9fda-4f1f-9e2d-0d8c401ef2b9",
      "name": "OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "BHXusSEU10unDNKa",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const SOURCE_NODE_NAME = \"Get Data\"; // Nome do nó de origem\nconst MAX_ITERATIONS = 20; // Número máximo de iterações para prevenir loops infinitos\n\n// Array para armazenar todos os nós combinados\nlet allNodes = [];\nlet projectData = null;\nlet totalPagesProcessed = 0;\n\nconsole.log(`Iniciando coleta de dados de múltiplas execuções do nó: ${SOURCE_NODE_NAME}`);\n\n// Loop para coletar todas as saídas disponíveis\nlet iteration = 0;\nlet hasMoreData = true;\n\nwhile (hasMoreData && iteration < MAX_ITERATIONS) {\n  try {\n    // Tenta obter os dados da iteração atual\n    const pages = $items(SOURCE_NODE_NAME, 0, iteration);\n    \n    if (!pages || pages.length === 0) {\n      console.log(`Nenhum dado encontrado na iteração ${iteration}. Finalizando coleta.`);\n      hasMoreData = false;\n      continue;\n    }\n\n    console.log(`Processando dados da iteração ${iteration}. Encontrados ${pages.length} itens.`);\n    \n    // Processa cada item encontrado na iteração\n    for (const item of pages) {\n      // Verifica se temos os dados no formato esperado\n      const project = item.json?.data?.organization?.projectV2;\n      const nodes = project?.items?.nodes;\n      \n      if (project && nodes) {\n        // Se ainda não temos metadados do projeto, salvamos da primeira ocorrência válida\n        if (!projectData) {\n          projectData = project;\n          console.log(`Metadados do projeto obtidos: ${project.title} (ID: ${project.id})`);\n        }\n        \n        // Adiciona os nós encontrados ao array principal\n        console.log(`Adicionando ${nodes.length} novos itens ao conjunto de dados`);\n        allNodes.push(...nodes);\n        totalPagesProcessed++;\n      } else {\n        console.log(`Aviso: Formato de dados inesperado na iteração ${iteration}`);\n      }\n    }\n    \n    // Avança para a próxima iteração\n    iteration++;\n\n  } catch (error) {\n    // Se ocorrer um erro, significa que não há mais dados disponíveis\n    console.log(`Fim dos dados disponíveis após ${iteration} iterações. Erro: ${error.message}`);\n    hasMoreData = false;\n  }\n}\n\n// Verifica se conseguimos coletar algum dado\nif (!projectData || allNodes.length === 0) {\n  console.error(\"Erro: Nenhum dado válido foi encontrado em qualquer iteração\");\n  return [{\n    json: {\n      error: true,\n      message: \"Não foi possível coletar dados válidos\"\n    }\n  }];\n}\n\n// Estatísticas finais\nconsole.log(`Coleta de dados concluída:`);\nconsole.log(`- Total de iterações processadas: ${iteration}`);\nconsole.log(`- Total de páginas válidas: ${totalPagesProcessed}`);\nconsole.log(`- Total de itens coletados: ${allNodes.length}`);\nconsole.log(`- Dados do projeto: ${projectData.title} (ID: ${projectData.id})`);\n\n// Constrói o resultado final no formato esperado pelo process_data.js\nconst result = {\n  data: {\n    organization: {\n      projectV2: {\n        id: projectData.id,\n        title: projectData.title,\n        fields: projectData.fields,\n        items: {\n          nodes: allNodes,\n        },\n      },\n    },\n  },\n};\n\n// Retorna o resultado consolidado\nreturn [{ json: result }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -20
      ],
      "id": "47bc85bc-506d-4181-bce4-7e323742711d",
      "name": "Combine Items",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        460,
        -40
      ],
      "id": "c0e6bc06-4e45-4e53-8bd5-6c9b202f6bd7",
      "name": "No Operation, do nothing"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        660,
        -40
      ],
      "id": "3b41636d-9cf5-420b-bce3-61e81d380b33",
      "name": "Wait",
      "webhookId": "f918907b-1ae6-4cd5-9d22-a050ae3a6bbe"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0e2e5b28-0ae4-4f67-9eb5-2a9d1523c712",
              "leftValue": "={{ $json[\"data\"][\"organization\"][\"projectV2\"][\"items\"]['pageInfo']['hasNextPage'] }}",
              "rightValue": "=true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        880,
        -40
      ],
      "id": "72ab36fa-dd65-4797-b0c1-1c7a8b3fb460",
      "name": "Has new page?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b49c3f98-b7ed-457d-863f-34af97f08861",
              "name": "cursor",
              "value": "={{$json[\"data\"][\"organization\"][\"projectV2\"][\"items\"][\"pageInfo\"][\"endCursor\"]}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        640,
        -440
      ],
      "id": "72c164c0-b518-417b-b63e-182580cc0e40",
      "name": "Set Next Page"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.github.com/graphql",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"query\": \"query($afterCursor: String) { organization(login: \\\"Interlis\\\") { projectV2(number: 3) { id title fields(first: 20) { nodes { ... on ProjectV2Field { id name dataType } ... on ProjectV2IterationField { id name configuration { completedIterations { id title startDate duration } iterations { id title startDate duration } duration startDay } } ... on ProjectV2SingleSelectField { id name options { id name } } } } items(first: 100, after: $afterCursor) { pageInfo { hasNextPage endCursor } nodes { id content { ... on Issue { title number state url assignees(first: 5) { nodes { login } } labels(first: 5) { nodes { name } } updatedAt createdAt } ... on PullRequest { title number state url assignees(first: 5) { nodes { login } } labels(first: 5) { nodes { name } } updatedAt createdAt } } fieldValues(first: 20) { nodes { ... on ProjectV2ItemFieldSingleSelectValue { name field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldDateValue { date field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldIterationValue { title startDate duration iterationId field { ... on ProjectV2FieldCommon { name } } } ... on ProjectV2ItemFieldNumberValue { number field { ... on ProjectV2FieldCommon { name } } } } } } } } } } }\",\n  \"variables\": {\n    \"afterCursor\": \"{{ $json.cursor ? $json.cursor: \"\" }}\"\n  }\n}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        240,
        -40
      ],
      "id": "d19fbea4-b4cb-4bee-8d02-f4a73a21bb51",
      "name": "Get Data",
      "executeOnce": false,
      "credentials": {
        "githubApi": {
          "id": "leqgDcgVWMXdmn3K",
          "name": "GitHub account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_data": {
      "main": [
        [
          {
            "node": "OpenAI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI": {
      "main": [
        [
          {
            "node": "Gmail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Items": {
      "main": [
        [
          {
            "node": "process_data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation, do nothing": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Has new page?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has new page?": {
      "main": [
        [
          {
            "node": "Set Next Page",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Combine Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Next Page": {
      "main": [
        [
          {
            "node": "Get Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Data": {
      "main": [
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Sao_Paulo",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "e9657b30-679f-408e-a153-89f948c611c8",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "680b771266285e0b2805aa12c56e24ddd5aa291181c2c29d2ca50bff81261932"
  },
  "id": "cg59ElMk7U7sY97I",
  "tags": [
    {
      "createdAt": "2025-05-20T16:43:04.301Z",
      "updatedAt": "2025-05-20T16:43:04.301Z",
      "id": "Ng6Yh4ZQW2L4O4sx",
      "name": "george"
    },
    {
      "createdAt": "2025-05-20T16:31:04.983Z",
      "updatedAt": "2025-05-20T16:31:04.983Z",
      "id": "YePntUlhLK5IUSTv",
      "name": "reports"
    },
    {
      "createdAt": "2025-05-20T16:31:15.518Z",
      "updatedAt": "2025-05-20T16:31:15.518Z",
      "id": "vSLxRvwJiQOzeGVX",
      "name": "production"
    }
  ]
}